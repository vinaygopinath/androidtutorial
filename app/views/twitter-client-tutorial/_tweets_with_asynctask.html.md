# Reading/Writing tweets with AsyncTask

In last lesson, we first wrote tweets to a file & later read from file to display it on Tweet List screen. In real scenario, this is how the flow is suppose to be.

1. When the screen loads, network call to fetch tweets is initiated. **The network call to fetch is asynchronous so that the Activity process is not blocked.** The user sees some kind of loading sign on the screen. 

2. Activity process reads the locally stored (stale) tweets & show them on the screen.

3. When the network call ends & new tweets are fetched, a fresh tweet array is created & the tweet list on the screen is re-created. The loading sign is hidden.

4. The new set of tweets are written to the file asynchronously so that the new tweets can be shown to the user ASAP. 

In this lesson, we will write tweets to the file & read from file asynchronously using **AsyncTask**. We will not be doing network calls though.

## AsyncTask intro & usage

As mentioned, AsyncTask class lets us execute things in parallel. It is like spawning a new thread which does things in parallel & exits silently when the tasks are done. This is important not to *block* the main Activity thread. Doing time taking things in the main Activity thread will lead to a *hung app*. If the user is expecting a new screen to load on a button click, the app will go non-responsive for sometime. 

The right way to use AsyncTask is by extending it. It has a function `doInBackground()` which does the real job for you. 

<pre>
private class MyAsyncClass extends AsyncTask {
		@Override
		protected Void doInBackground() {
		  //do your background job
		  return null;
		}
}
</pre>

To execute the task, we simply do

     MyAsyncClass().execute()

In case you need to pass parameters to the class, you can do it as below
<pre>
private class MyAsyncClass extends AsyncTask<span class="highlight">&lt; <i>parameter 1 type</i>, <i>parameter 2 type</i> &gt;</span> {
		@Override
		protected Void doInBackground(<span class="highlight">param1, param2</span>) {
		  //do your background job
		  return null;
		}
}

<span class="highlight">MyAsyncClass().execute(param1, param2)</span>

</pre>


### Assignment 1 - move writeTweets() inside AsyncTask

In last lesson, we had writeTweets() & readTweets() happening one after another in TweetListActivity.java . The first thing we are going to do is to write tweets asynchronously. 

** 1. Create new class AsyncFetchTweets **

We are going to create a new class - AsyncFetchTweets. As per java norms, lets create a new file for that - AsyncFetchTweets.java . The class should extend AsyncTask . It should also accept tweets array as argument as writeTweets() function would be needing it. 

Hint: Use the AsyncTask code from the theory above . 

** 2. Move random tweet generation & writeTweets() to AsyncFetchTweets **

Instead of TweetListActivity calling writeTweets(), it should actually be calling AsyncFetchTweets().execute(tweets) which in-turn will execute writeTweets(). Use the code snippet below & fill it. 

		protected Void doInBackground() {
		  //put in the code to generate random tweets & store in tweets array
		  .
		  .
		  //write the tweets array to the file
		}

** 3. Simulate network call with Thread.sleep **

Just to simulate a network call of around 5 seconds to fetch tweets, introduce sleep inside doInBackground() function before writing the tweets. 

`AsyncFetchTweets.java`

<pre>
	protected Void doInBackground() {
      <span class="highlight">//simulate network delay
	  Thread.sleep(5000);</span>
	  
	  //put in the code to generate random tweets & store in tweets array
	  <span class="highlight">//in real scenario, tweets array is generated by data from network call</span>
	   .
	   .
	  //write the tweets array to the file
    }
</pre>

Run your app. You will see empty tweets the first time your app loads. From the second time, you will see the tweets. 


## Why there are no tweets first time

In the previous lesson, the reading tweets from file happened once writing to the file is done. Here, they are happening in parallel. Since there is a 5 sec delay in writing tweets to file, when readTweets() tries to read the tweets, the cached file is empty. 

### Assignment - add 'No tweets found' 

Adding a TextView with id **@android:id/empty** in activity_tweet_list.xml takes care of this situation. Put **android:text** attribute as 'No tweets found' for the TextView.

Hint: The TextView should be placed just **after** ListView element **& not inside it**.

Run your app & deploy. You should see a 'No tweets found' screen the first time you go to the tweet list screen from login. 

## Updating screen post network call simulation

In the background task, we are simply generating random tweets & writing to cached file after a delay. In real scenario, once the new set of tweets are fetched, they need to be shown on the screen. 

We already have the code to show the tweets on the screen. To keep our code DRY (Don't Repeat Yourself), we are going to first create a function which would be responsible to show up the tweets on the screen. We will call the functions from main Activity thread as well as from inside the background task. 

### Assignment - show tweets in the very first app load

** 1. Create new function renderTweets() **

Create a public static function **renderTweets()** in TweetListActivity class. We need a public static function because it needs to be invoked from AsyncFetchTweets class as well.  Move all the tweet rendering code to the function & call the function from onCreate() . 

** 2. Invoke the same function from inside doInBackground(). **

Hint: In java, you can invoke a static function of another class as <i>ClassName</i>::<i>FunctionName</i>

Once done, go ahead & deploy the app. You should be able to see the list of tweets after around 5 seconds of Tweet List screen showing up the first time app loads. From the second app load, the tweets stay the same so you would probably will not see any change after 5 sec. 

### Assignment - create another AsyncTask for writing tweets to file

AsyncUpdateTweets class is primarily responsible to fetch tweets asynchronously & show them on the screen as soon as they are fetched. We are also writing the tweets in the file which can again happen asynchronously. 

1. Create another class AsyncWriteTweets.java . 
2. Move writeTweets() function to the doInBackground() function of the class. 
3. Call the class execute() function from AsyncFetchTweets class.

Do the changes & run your app. The tweets should show up **slightly faster after 5 seconds** as compared to the previous case.
